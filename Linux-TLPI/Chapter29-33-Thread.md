- 概述：
	- 线程是允许应用程序并发执行多个任务的一种机制。同一程序中所有线程都会独立执行相同程序，且共享一份全局内存区域，其中包括初始化数据段、未初始化数据段、堆内存段。![[thread.png|500|400]]
	- 采用多进程的限制：
		- 进程间的信息难以共享。除了只读代码段外，父子进程未共享内存，必须采用进程间通信方式
		- 调用`fork()`来创建进程的代价相对较高。即便使用（copy-by-write）技术，仍然要复制诸如内存页表、文件描述符表等进程属性，开销不菲
	- 线程解决上述问题:
		- 线程间能方便快速共享信息：将数据复制到全局/堆（共享）变量中即可。（同步）
		- 线程创建速度快，无需复制内存页，页表等
	- POSIX线程API：Pthread API见附表
	- 线程和errno:
		- 传统unix api中errno为全局整型，然而多线程不行——引发竞争条件：线程调用函数通过全局errno返回错误时，会与其他发起函数调用检查errno的线程混淆
		- 每个线程均有属于自己的errno
	
|        数据类型         |              描述              |
| :-----------------: | :--------------------------: |
|      pthread_t      |            线程 ID             |
|   pthread_mutex_t   |         互斥对象（Mutex）          |
| pthread_mutexattr_t |            互斥属性对象            |
|   pthread_cond_t    |   条件变量（condition variable）   |
| pthread_condattr_t  |          条件变量的属性对象           |
|  pthread_key_t<br>  |        线程特有数据的键（Key）         |
| pthread_once_t<br>  | 一次性初始化控制上下文（control context） |
|   pthread_attr_t    |           线程的属性对象            |

- 创建线程
	- 启动程序时，产生的进程只有单条线程，称之为初始或主线程
	- `Pthread_create()`负责创建一条新线程
	```cpp
	#include<pthread.h>
	int pthread_create(pthread_t* thread,const pthread_attr_t *attr, 
						void*(*start)(void*),void *arg)
						//return 0成功，或者正数表示错误
	```
- 终止线程
	- 如下方式终止线程运行：
		1. 线程start函数执行return语句并返回指定值
		2. 线程调用`pthread_cancel()`
		3. 调用`pthread_cancel()`取消线程
		4. 任意线程调用了`exit()`，或主线程执行了return语句，都会导致进程中所有线程立刻终止
- 线程ID（Thread ID）
	- 进程内部每个线程都有一个唯一标识，称为线程ID。线程ID会返回给`pthread_create()`的调用者，一个线程可以通过`pthread_self()`来获取自己的线程ID
- 连接（joing）已终止线程
	- 函数`pthread_join()`等待由thread标识的线程终止。如果线程已经终止，其会立即返回
	- 若线程未分离，则必须使用`pthread_join()`来进行连接。如果未能连接，那么线程终止时将产生僵尸线程。浪费系统资源
	- 与进程中的`waitpid`区别:
		- 线程中对等关系
		- 。。。
- 线程的分离
	- 默认情况线程可连接的——线程退出时其他线程可以调用`pthread_join()`获取返回状态
	- 有时，不关心返回状态，只希望系统在线程终止时自动清理并移除它——可以通过调用`pthread_detach()`将该线程标记为分离状态
- 线程v.s.进程
	- 除了数据，多线程还可以共享某些其他信息
	-  除了前述进程的限制，线程也有缺点:
		1. 某个线程的bug可能危及该进程的所有线程，因为它们共享相同地址空间和其他属性
		2. 它们都在争用宿主进程中有限虚拟地址空间
		3. 多线程中处理信号要小心设计——一般避免使用
		4. 多线程应用，所有线程必须运行同一程序；多进程可以不同

# 线程同步

- 互斥量：保护对共享变量的访问









