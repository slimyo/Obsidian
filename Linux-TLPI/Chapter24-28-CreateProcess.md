- 进程的创建
	- `fork()`创建新进程：
		- 调用创建子进程，其拥有相同程序文本段，不同栈段、数据段及堆段（初始为父进程的拷贝）。
		- 习惯调用方法：
			```cpp
			pid_t childPid;
			switch(childPid=fork()){
			case -1://调用失败
				//error
			case 0://fork 在子进程中返回0
				//child action;
			default://fork 在父进程中返回子进程pid
				//parent action;
			}
			//child and parent actions;
			```
		- 父子进程的文件共享：执行`fork()`时，子进程会获得父进程所有文件描述符的副本
		- `fork()`的内存语义:
			- 概念上可以认为，fork对父进程程序段、数据段、堆、栈段创建拷贝。
			- 拷贝多造成浪费：常常fork后跟随exec，新程序代替代码段，重新初始化数据段、堆、栈段
			- 两种技术避免浪费：
				1. 内核将每一进程代码段标记为只读，进程无法修改自身代码。父子进程共享同一代码段，fork为子进程构建代码段时，其所构建的一系列进程级页表项均指向父进程相同的物理内存
				2. 对于父进程的数据段、堆栈段中的各页，内核采用写时复制（copy-on-write）技术处理——最初子进程这些各页表（只读）指向父进程相同物理内存页。调用fork后，内核会捕获对这些页的修改企图，为要修改的页面创建拷贝
		- 系统调用`vfork`
		- `fork()`之后的竞争条件:
			- 调用`fork()`后，无法确定父、子进程间谁率先访问CPU（父子进程顺序依据系统可能不一样）
- 进程的终止
	- `_exit()`和`exit()`：
		- `_exit(int status)`总是终止该进程，无返回值，父进程可通过`wait()`获取`status`终止状态（仅低8位有效）
		- `exit()`是将其包装的C语言库函数，含有调用退出处理程序、刷新stdio缓冲区
		- 从main函数中return也是终止程序的方法（只有在退出处理过程中要用到main函数本地变量的情况下，其与exit调用不同）
	- 进程终止的细节：
		- 关闭文件描述符......
	- 退出处理程序
		- `atexit()`:注册无传参、无返回值的处理函数
		- `on_exit()`:注册有exit参数status和参数args的处理函数
		- 先执行后注册的处理程序
		- `fork()`创建的子进程会继承父进程的处理函数(`exec()`函数会替换掉)
	- `fork()`,`stdio`缓冲区`_exit()`间的交互:
		- `fork()`创建的进程会复制缓冲区
		- `fflush()`可以用来刷新缓冲区，在fork前使用避免重复输出
		- `setvbuf()`,`setbuf()`可以用来关闭stdio流缓冲
		- 子进程调用`_exit()`可以不再刷新缓冲区：一个设计方法，创建子进程的应用中，只有一个进程调用`exit()`,其他调用`_exit()`
- 监控子进程
	- 系统调用`wait()`
		- 如果父进程已经创建了多个子进程，使用`wait()`将无法等待某特定子进程的完成，只能按顺序等待下一个子进程退出
		- 保持阻塞
		- 只能发现已经终止子进程，对子进程因某信号停止、恢复的情况无能为力
	- 系统调用`waitpid()`
		- 突破上述限制
	- 返回的`status`值
		- 含义。。。
	- 从信号处理程序中终止进程
		- 在信号处理程序中调用`_exit()`终止进程，父进程会认为子进程正常终止
		- 要通知父进程自己因某个信号终止，子进程的信号处理程序应该首先将自己废除，然后发出同样信号，该信号终止这一子进程
	- 系统调用`waitid()`
		- 与`waitpid()`相比，可以通过在option更精确控制等待的事件
	- `wait3()`，`wait4()`:
		- 参数rusage指向的结构中返回终止进程的资源使用情况
	- 孤儿进程
	- 僵尸进程：
		- 子进程已经终止，系统仍允许父进程执行`wait()`来确定进程如何终止的。内核通过将子进程转换为僵尸进程来处理这种情况——释放进程的大部分资源，保留内核进程的包含子进程id、终止状态、资源使用数据等信息的一条记录。
		- 父进程执行`wait()`后，删除僵尸进程
		- 父进程应该执行`wait()`防止僵尸进程累计
	- `SIGCHLD`信号：
		- 使用`wait()`外，还可以：1.调用不带`WNOHANG`标志的wait或waitpid，阻塞。2.父进程周期性调用带`WNOHANG`的waitpid，非阻塞轮询
		- 使用`SIGCHLD`避免上述方法中的：1.不希望阻塞。2.反复轮询的CPU资源浪费和程序复杂度
		- 子进程终止，系统都会向其父进程发送`SIGCHLD`信号，（默认忽略）可在信号处理程序中使用`wait()`等方法，处理僵尸进程。
		- 由于信号处理程序会将引发调用的信号阻塞，为了处理相继的终止子进程，应该在信号处理程序中循环调用带`WNOHANG`的waitpid，非阻塞轮询
		- 忽略终止的子程序：
			- 更可能这样处理终止子进程:将对`SIGCHLD`的处置显式设置为忽略（`SIG_IGN`）,系统从而会将其后终止的子进程立即删除，不转换为僵尸进程
- 程序的执行
	- 执行新程序`execve()`:
		- 将新程序加载到某一进程的内存空间：丢弃旧有程序，进程的堆栈段、数据段被新程序相应替换
		- 进程ID不变
		- 若对指定的程序文件设置了`set-user-ID/set-group-ID`权限位，则系统调用会在执行该文件时，将进程的有效用户(组)ID-->程序文件的属主(组)ID。利用这一机制，可以令用户在运行特定程序时临时获得特权
	- `exec()`库函数:
		- 建立在`execdve()`调用之上，指定程序名称、参数列表、环境变量的方式不同
		- `execle`,`execlp`,`excvp`,`execv`,`execl`
		- 环境变量PATH
			- 以冒号:分隔，由多个目录名（路径前缀）组成的字符串
			- 通常会将当前工作目录排除在root的PATH之外，防止执行当前工作目录下与标准命令同名程序，或拼错命令执行了当前目录下的程序
	- 解释器脚本
		- 解释器：能够读取并执行文本格式命令的程序。
		- 编译器：将输入源代码翻译为可在真实或虚拟机器上执行的机器语言
		- 解释器还能够从脚本（script）文本文件中读取和执行命令
			- unix内核运行解释器脚本，要满足1。赋予脚本文件可执行权限。2.文件起始行必须指定脚本解释器路径名（`#! interpreter-path[optional-arg]`）
	- 文件描述符与`exec()`
		- 默认，由`exec()`调用程序打开的所有文件在`exec()`执行过程中都保持打开状态，且在新程序中依然有效
	- 信号与`exec()`
		- `exec`将现有进程文本段丢弃
	- 调用`system()`执行shell命令
	- `system()`的实现
- 详述进程创建和程序执行
	- 进程记账
		- 打开进程记账功能后，内核会在每个进程终止将一条记账信息写入系统级的进程记账文件
	- 系统调用`clone()`
		- Linux特有，创建新进程，对步骤的控制更为精准。主要用于线程库的实现
	- 创建进程的速度：![[进程创建速度.png]]
	- `exec()`和`fork()`对进程属性的影响：
		- 改变的和不变的进程属性见表:
		![[fork1 (1).png]]![[fork1 (2).png]]![[fork1 (3).png]]![[fork1 (4).png]]![[fork1 (5).png]]![[fork1 (6).png]]