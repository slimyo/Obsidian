- 程序：包含了一系列信息的文件（描述了如何在运行时创建一个进程）
	-  二进制格式标识（描述可执行文件格式的元信息metainformation）内核（kernel）根据它解释文件中其他信息
	- 机器语言指令：对程序算法编码
	- 程序入口地址
	- 数据：变量初始值和程序使用的字面常量值
	- 符号表及重定位表：描述程序中函数和变量的位置及名称
	- 共享库及动态链接信息
	- 其他信息：用于描述如何创建进程
- 进程：可执行程序实例。从内核角度看包含：
	- 用户内存空间：
		1. 程序代码
		2. 使用的变量
	- 一系列内核数据结构：维护进程的状态信息
		1. 与进程相关的标识号
		2. 虚拟内存表
		3. 打开文件的描述符表
		4. 信号传递与处理的有关信息
		5. 进程资源与使用限制
		6. 当前工作目录
		7. 其它
- 进程号（PID）：一个正数，用于唯一标识系统中的某个进程。
	- 系统调用getpid：
	```cpp
	#include<unistd.h>
	pid_t getpid(void);
	```
	- init进程：进程号为1.
	- 父进程：每个进程都有一个创建自己的父进程。
		- 进程的父进程终止，子进程将由init进程收养
		- 系统调用getppid:
	```cpp
	pid_t getppid(void);
	```
- 进程内存布局：分配的内存由很多段(segment)组成
	- 文本段:进程运行的程序机器语言指令。只读，可共享
	- 初始化数据段（用户初始化数据段）：显示初始化的全局、静态变量
	- 未（零）初始化数据段：未显式初始化的全局、静态变量
	- 栈：由栈帧组成。系统为当前调用函数分配栈帧
		- （用户）栈帧：包含
			1. 函数实参、局部变量
			2. （函数）调用的链接信息：CPU寄存器数据等。保护现场
	- 堆：为变量动态分配内存的区域
	- 全局符号`extern char etext,edata,end;`:
		- 用于获得文本段、初始化数据段、未初始化数据段段位下一字节地址 
![[进程内存结构.png|500|400]]
- 虚拟内存：
	- 特性：访问局部性：
		-  空间局部性：程序倾向于访问最近访问过内存地址附近的内存
		- 时间局部性：程序倾向在不久将来再次访问访问过的内存地址
	- 结果：使进程的虚拟地址空间和RAM物理地址空间隔离
	- 优点:
		1. 进程与进程、进程与内核隔离：一个进程不能读取或修改零一进程或内核的内存
		2. 多个进程内存共享：内核可以使不同进程页表条目指向相同RAM页
		3. 便于内存保护机制：对页表条码标记，可读、可写、可执行等
		4. 程序员、编译器、链接器等工具无需关注程序的RAM物理布局
		5. 程序只需部分驻留在内存中：程序加载、运行速度快；进程所占内存（虚拟内存）能超过RAM容量
		6. RAM中容纳的进程数量增加；往往提高CPU利用率
	- 页：将每个程序使用的内存切割成小型的、固定大小的单元。
	- 页帧：将RAM划分为一系列与虚拟页尺寸相同的页帧。
	- 驻留集：任意时刻，每个程序仅有部分页需要驻留在物理页帧中，它们构成集。
	- 交换区：程序未使用的页，拷贝保存在的磁盘空间保留区域
	- 页面错误：程序欲访问的页面目前未在驻留集中。此时内核挂起进程的执行，从磁盘中将页面载入内存。
	- 进程虚拟地址空间：可为进程所用的所有虚拟内存页面集合
	- 页表：内核维护的，描述每页在进程虚拟地址空间的位置。
![[页表.png|500|400]]

- 命令行参数`arcg,argv`
	- `int argc`：命令行参数个数
	- `char* argv[]`：指针数组，指向命令行参数。
		- 参数是（以空字符结尾）的字符串
		- `argv[0]`:调用程序名称
	- 仅对`main()`函数可用
	- 其他函数使用该参数方法：
		1. 将其以参数形式传递给函数
		2. 设置指向其的全局变量
		3. （linux）的`/proc/PID/cmdline`文件读取任一进程命令行参数
		4. GNU C库两个全局变量(`<errno.h>`)
![[argv.png]]

- 环境列表：
	- 字符串数组：形式`name=value`的“名称-值”对集合
	- 新进程创建时会继承父进程的环境副本：原始进程间通信方式
	- shell中使用`export`命令添加环境变量:`export env_name=/bin/bash`
	- shell中使用`printenv`命令打印当前环境列表
	- (linux)的`/proc/PID/environ`文件检查任一进程环境列表
	- 程序中访问：
		1. 全局变量`char** environ`访问环境列表（C运行时启动代码定义、赋值）
		2. `char* getenv(const char*name);//#include<stdlib.h>`函数检索单个值
	- 修改环境:
		1. `int putenv(char*string);//#include<stdlib.h>`字符串（非复制）设置为环境
		2. `int setenv(const char*name,const char* value,int overwrite);//#include<stdlib.h>`自动分配内存缓冲区将字符串复制到内部，来创建
		3. `int unsetenv(const char*name);//#include<stdlib.h>`移除变量
		4. 将`environ=NULL`清除环境
		5. `int clearenv(void)`同上（注意：`setenv()与clearenv()`可能导致内存泄漏，后者可能不释放缓冲区）
- 非局部跳转
	- 跳转到当前执行函数外的某个位置（`goto`语句不能实现，未知目标函数是否在栈上）
	- `setjmp()`
		- 只能在下述语境使用
			1. 构成选择或者迭代语句(if,switch,while等)的整个控制表达式
	- `longjmp()`
		- 滥用
	- 编译器优化问题：声明变量为`volatile`防止编译器优化