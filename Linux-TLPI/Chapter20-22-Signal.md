
- 信号：
	- def：事件发生时对进程的通知机制，软件中断
	- 通常产生自内核，产生信号的事件如下：
		1. 硬件异常
		2. 用户键入特殊字符：如中断字符`Ctrl-C`暂停字符`Crtl-Z`等
		3. 软件事件：如定时器到期，进程执行CPU时间超限等
	- 在`<signal.h>`中以SIGxxx形式对信号进行了定义（从1开始的小整数）
	- 分类：
		1. 用于内核向进程通知事件：编号1-31，标准信号
		2. 实时信号
	- 等待：产生信号和到达期间
	- 信号的到达:
		1. 若进程在运行或内核要调度它运行，则等待信号马上送达
		2. 若要确保一段代码不为传递信号中断，可以将信号加入进程的信号掩码中
	- 信号掩码：阻塞信号的到达，直至将信号从掩码中移除
	- 进程接收信号的默认操作（执行其一）：
		1. 忽略信号
		2. 终止进程
		3. 产生核心转储文件，同时进程终止：包含对进程虚拟内存的镜像，可加载到调试器中检查进程终止时的状态
		4. 暂停进程
		5. 暂停中恢复进程
	- 信号处置设置：改变信号到达的响应行为（下列之一）
		1. 采取默认行为：恢复对信号处置的修改
		2. 忽略信号：适用于默认行为终止进程的信号
		3. 执行信号处理器程序
	- 信号处理器：程序员编写的函数，响应信号
	- （linux）`/proc/PID/status`文件掩码字段可以查看进程对信号的处理
	- 改变信号处置：
		1. `siganl()`:
		```cpp
		# include<signal.h>
		void (*signal(int sig,void (*hander)(int))(int);
		//信号处理程序
		void hander(int sig){/*处理代码*/}
		```
		2. `sigaction()`(signal()`无法在不改变信号处置的同时，获取当前信号处置。)
			```cpp
			int sigaction(int sig,const struct sigaction* act,struct sigaction* oldact);
			struct sigaction{
			void (*sa_handler)(int);//handler地址
			sigset_t sa_mask;//一组信号，调用handler处理器程序时阻塞
			int sa_flags;//位掩码，控制信号处理过程选项
			void (*sa_restorer)(void)//内部调用
			};
			```
	- 发送信号`kill()`:
		- 与shell的kill命令类似，进程能调用向另一进程发送信号。
		- 早期Unix实现多数信号默认终止进程，故称为kill
		- 使用：
			```cpp
			#include<signal.h>
			int kill(pid_t pid, int sig);
			```
		- 参数`pid`标识一个或多个目标进程:查阅4种情况
		- 权限：进程发送信号给另一进程需要适当权限：
			1. 特权级(CAP_KILL)进程可以向任何进程发送
			2. 以root用户和组运行的init进程，仅能接收已安装了处理器函数的信号（防止系统管理员意外杀死）
			3. ID匹配时非特权进程也能向另一进程发送信号![[killid.png]]
			4. `SIGCONT`信号特殊：无论用户ID检查，非特权进程均可向同一会话中任何其他进程发送
			5. 进程无权发送给请求pid将调用kill失败，且设置errno为EPERM
		- 检查进程的存在:
			1. 检查特定进程ID是否存在：使用kill设置参数sig为0（空信号）查看调用是否成功。（不能保证特定程序运行）
			2. `wait()`系统调用
			3. 信号量和排他文件锁
			4. 诸如管道和FIFO类的IPC通道
			5. `/process/PID`接口
		- 其他方式：
			- `raise()`
			- `killpg()`
	- 显示信号描述：每个信号的可打印说明
		- 位于数组`sys_siglist`中，`sys_siglist[SIGNAME]`调用
		- `strsignal()`函数
			```cpp
			#include<signal.h>
			extern const char * const sys_siglist[];
			char* strsignal(int sig);
			```
	- 信号集：
		- 表示多个信号的数据结构
		- 数据类型`sigset_t`
		- 操纵信号集的函数：
			- `int sigemptyset(sigset_t* set)`
			- `int sigfillset(sigset_t* set)`
			- `int sigaddset(sigset_t* set,int sig)`
			- `int sigdekset(sigset_t* set,int sig)`
			- `sigismember,sigandset,sigirset,sigisemptset`等
	- 信号掩码：内核为每个进程维护的一组信号，阻塞这些信号对进程的传递
		- 向掩码中添加信号：
			1. 调用信号处理器程序时，可将引发调用的信号自动添加
			2. 使用`sigaction()`建立信号处理器程序时，可以指定处理器程序的阻塞信号
			3. `sigprocmask()`系统调用随时显式添加或者移除信号
			- `int sigprocmask(int how,const sigset_t* set,sigset_t* oldset)`
			- 注:无法阻塞`SIGKILL,SIGSTOP`信号
	- 处于等待状态的信号：
		- 进程接受了一个进程正在阻塞的信号，会将该信号加入等待信号集中
		- 只是掩码，不会记录信号接受次数
		- 查看等待状态的信号:`int sigpending(sigset_t* set)`
	- 等待信号：
		- `pause()`暂停进程执行，直至信号处理函数中断该调用（或未处理信号终止进程）
	
	- 附：标准信号表：

| 信号名称      | 信号值 | 描述             | 默认行为        | SUS要求 |
| --------- | --- | -------------- | ----------- | ----- |
| SIGHUP    | 1   | 终端挂起或控制进程终止    | 终止进程        | 是     |
| SIGINT    | 2   | 键盘中断（Ctrl+C）   | 终止进程        | 是     |
| SIGQUIT   | 3   | 键盘退出（Ctrl+\）   | 终止进程并生成核心转储 | 是     |
| SIGILL    | 4   | 非法指令           | 终止进程并生成核心转储 | 是     |
| SIGTRAP   | 5   | 跟踪/断点陷阱        | 终止进程并生成核心转储 | 是     |
| SIGABRT   | 6   | 中止信号（abort()）  | 终止进程并生成核心转储 | 是     |
| SIGBUS    | 7   | 总线错误           | 终止进程并生成核心转储 | 是     |
| SIGFPE    | 8   | 浮点异常           | 终止进程并生成核心转储 | 是     |
| SIGKILL   | 9   | 强制终止           | 终止进程（不可捕获）  | 是     |
| SIGUSR1   | 10  | 用户自定义信号1       | 终止进程        | 是     |
| SIGSEGV   | 11  | 段错误（无效内存访问）    | 终止进程并生成核心转储 | 是     |
| SIGUSR2   | 12  | 用户自定义信号2       | 终止进程        | 是     |
| SIGPIPE   | 13  | 管道破裂（向无读端的管道写） | 终止进程        | 是     |
| SIGALRM   | 14  | 定时器信号（alarm()） | 终止进程        | 是     |
| SIGTERM   | 15  | 终止信号           | 终止进程        | 是     |
| SIGSTKFLT | 16  | 协处理器栈错误        | 终止进程        | 否     |
| SIGCHLD   | 17  | 子进程停止或终止       | 忽略          | 是     |
| SIGCONT   | 18  | 继续执行（如果停止）     | 继续/忽略       | 是     |
| SIGSTOP   | 19  | 停止进程           | 停止进程（不可捕获）  | 是     |
| SIGTSTP   | 20  | 终端停止（Ctrl+Z）   | 停止进程        | 是     |
| SIGTTIN   | 21  | 后台进程尝试从终端读     | 停止进程        | 是     |
| SIGTTOU   | 22  | 后台进程尝试向终端写     | 停止进程        | 是     |
| SIGURG    | 23  | 套接字紧急数据        | 忽略          | 是     |
| SIGXCPU   | 24  | CPU时间限制超出      | 终止进程        | 是     |
| SIGXFSZ   | 25  | 文件大小限制超出       | 终止进程        | 是     |
| SIGVTALRM | 26  | 虚拟定时器信号        | 终止进程        | 是     |
| SIGPROF   | 27  | 性能分析定时器信号      | 终止进程        | 是     |
| SIGWINCH  | 28  | 窗口大小改变         | 忽略          | 是     |
| SIGIO     | 29  | I/O就绪          | 终止进程        | 是     |
| SIGPWR    | 30  | 电源故障           | 终止进程        | 否     |
| SIGSYS    | 31  | 系统调用错误         | 终止进程并生成核心转储 | 是     |

---
- 信号处理器函数
	- 可能随时打断主程序；内核代表进程来调用处理器程序，返回时主程序会在断电恢复执行。
	![[信号处理器.png]]
	- 两种常见设计：将信号处理器函数设计得越简单越好（降低引发竞争条件的风险）
		1. 信号处理器函数设置全局性标志变量并退出。主程序周期性检查和采取动作（主程序无法检查时，采用专用管道）
		2. 执行某种类型的清理动作，后进程终止或使用非本地跳转将栈解开并将控制返回到主程序预定位置
	- 处理器函数执行期间，如果多次产生同类信号，仍然会将其标记为等待状态，但稍后只会传递一次。
	- 可重入和异步信号安全函数：并非所有系统调用和库函数均可以在信号处理器函数中安全调用
		- 可重入：同一进程的多条线程可以同时安全地调用某以函数，该函数就是可重入的。
			- 更新全局变量或静态数据结构的函数可能不可重入
			- malloc和free族和使用它们的库不可重入
			- 使用了经静态分配的内存来返回信息的函数不可重入
			- 将静态数据结构用于内部记账的函数printf，scanf等不可重入
		- 异步信号安全函数：当从信号处理器函数调用时，可以保证其实现是安全的（可重入的函数，或者信号处理函数无法将其中断）
	- 编写信号处理器函数的两种选择：（简-信号处理函数中不调用不安全函数）
		- 确保信号处理器函数代码本身可重入，且只调用异步信号安全的函数
		- 主程序执行不安全函数或去操作信号处理器可能更新的全局数据结构时阻塞信号
	- 信号处理函数内部可能改变errno值，可在入口保存errno值，出口恢复
	- 全局变量和`sig_atomic_t`：
		- 信号处理器函数设置全局标志、主程序检查程序设计时，应该声明`volatile`关键字
		- 共享的全局变量应该使用`sig_atomic_t`类型，保证对全局变量的访问为原子操作
	- 终止信号处理函数的其他方法：（除去返回主程序外）
		1. 以`_exit()`终止进程。处理器先做清理工作
		2. 使用kill发送信号杀死进程
		3. 从信号处理函数中执行非本地跳转
		4. 使用`abort()`函数终止进程，并核心转储
	- 从信号处理函数中执行非本地跳转：
		- 问题：`setjmp`和`longjmp`不会对掩码进行修复
		- 使用`sigsetjmp`和`siglongjmmp`
	- 异常终止程序:`abort()`并生成核心转储
	- 在备选栈中处理信号：`sigaltstack()`
		- 进程对栈的拓展突破对栈大小限制，内核无法为信号处理函数创建一帧进程栈
		- 分配“备选信号栈”的内存，作为信号处理器函数的栈帧
	- `SA_SIGINFO`标志：
		- 使用`sigation`创建处理器函数时若设置了该标志，则可在接收信号时获取附加信息。
	- 系统调用的中断和重启：
		- 系统调用时信号传递，导致调用信号处理器函数，中断系统调用，希望重启系统调用
		- 法一：设置宏等手动重启方式
		- 法二：调用指定了`SA_RESTART`标志的sigaction来创建信号处理器函数，令内核代表进程自动重启系统调用，还无需处理系统调用可能返回的EINTR错误。
		- 注意：上述标志只对部分库函数有效
		- `siginterrupt()`用于改变信号的上述标志
- 高级特性：
	- 核心转储文件：
		- 引发程序生成核心转储文件方式之一：键入退出字符`Control-\`生成`SIGQUIT`信号
		- 进程读写权限、文件目录、进程资源设置、挂载工作目录权限、文件属主等设置会导致不产生核心转储文件
		- 命名：`/proc/sys/kernel/core_pattern`文件包含的格式化字符控制
	- 特殊：`SIGKILL`和`SIGSTOP`信号默认行为无法改变，也不能阻塞。总是能终止或暂停一个进程。（除了内核睡眠时）。`SIGCONT`总恢复进程运行
	- （可中断和不可中断）进程睡眠状态：
		- `TASK_INTERRUPTIBLE`:进程等待某一事件。这种状态下进程产生一个信号，操作将中断，传递来的信号将唤醒进程
		- `TASK_UNINTERRUPTIBLE`:进程在等待某些特定类型事件。系统摆脱状态前，不会把信号传递给进程。（此时某些故障可能导致`SIGKILL`无法终止进程）
		- `TASK_KILLABLE`：类似上述，但进程接收致命信号时会被唤醒。
	- 硬件产生信号：
		- 硬件异常时，进程从硬件异常信号的处理器函数返回，或忽略、阻塞这些信号时，进程的行为未定义。
		- 正确处理硬件产生信号：接受信号的默认行为（终止进程）或编写不会正常返回的处理器函数
	- 同步信号和异步信号：
		- 异步：引发信号的产生（进程、内核）事件，和其发生和进程的执行无关
		- 同步：信号的产生由进程本身的执行造成——立即传递信号
	- 信号传递的时机与顺序
		- 何时传递信号：
			- 同步信号：立即传递。
			- 异步信号：内核将等待信号传递给进程的时机是：**进程正在执行，且发生由内核态到用户态的下一次切换时**——1.进程在前度超时后再次获得调度时（时间片的开始）或者2.系统调度完成时
		- 解除对多个信号阻塞时，信号的传递顺序：
			- Linux内核按照信号编号的升序传递（无法保障传递顺序）
			- 多个解除阻塞信号等待传递时，如何在信号处理器函数执行器件发生了内核态和用户态的切换，将中断此处理器函数，转而调用第二个处理器函数，如此递进
	- 实时信号：
		- 信号范围扩大
		- 队列和管理
		- 传递信号时可指定伴随数据
		- 不同实时信号传递顺序得到保障
	- 发送实时信号`sigqueue()`
	- 使用掩码来等待信号：`sigsuspend()`
		- 临时阻塞一个信号
		- 解除对信号的阻塞，然后暂停执行，直到有信号到达
		- 相当于将`sigprocmask(SIG_SETMASK,&mask,&preevMask);pause();sigprocmask(SIG_SETMASK,&prevmMask,NULL);`封装为原子操作。防止竞态，保证等待的是目标第一个信号
	- 同步方式等待信号：不用上述方式的编写信号处理器函数
		- `sigwaitinfi()`
	- 通过文件描述符获取信号：`signalfd()`系统调用
	- 利用信号在进程间通信（IPC）：可以，但繁琐而难
		- 异步信号要面对如可重入性、竞态条件，正确处理全局变量等问题
		- 没有对标准信号做排队处理，存在排队数量限制
		- 信号携带信息有限